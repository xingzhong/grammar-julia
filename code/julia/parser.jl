# parser julia
using Distributions
include("Grammar.jl")
include("Inside.jl")


S = Nonterminal("S")
A = Nonterminal("A")
B = Nonterminal("B")
C = Nonterminal("C")
up = Terminal("up", MultivariateNormal([0.0, 1.0, 0.0],eye(3)))
down = Terminal("down", MultivariateNormal([0.0, -1.0, 0.0],eye(3)))
left = Terminal("left", MultivariateNormal([-1.0, 0.0, 0.0],eye(3)))
right = Terminal("right", MultivariateNormal([1.0, 0.0, 0.0],eye(3)))
front = Terminal("front", MultivariateNormal([0.0, 0.0, 1.0],eye(3)))
back = Terminal("back", MultivariateNormal([0.0, 0.0, -1.0],eye(3)))
stop = Terminal("stop", MultivariateNormal([0.0, 0.0, 0.0],eye(3)))

push!(Nonterminals, S)
push!(Nonterminals, A)
push!(Nonterminals, B)
push!(Nonterminals, C)
push!(Terminals, up)
push!(Terminals, down)
push!(Terminals, left)
push!(Terminals, right)
push!(Terminals, front)
push!(Terminals, back)
push!(Terminals, stop)
push!(grammar, Production(S, A, B, 1.0/6))
push!(grammar, Production(S, A, C, 1.0/6))
push!(grammar, Production(S, B, C, 1.0/6))
push!(grammar, Production(S, B, A, 1.0/6))
push!(grammar, Production(S, C, A, 1.0/6))
push!(grammar, Production(S, C, B, 1.0/6))
push!(grammar, Production(A, A, A, 0.33))
push!(grammar, Production(A, A, B, 0.33))
push!(grammar, Production(A, A, C, 0.33))
push!(grammar, Production(B, B, A, 0.33))
push!(grammar, Production(B, B, B, 0.33))
push!(grammar, Production(B, B, C, 0.33))
push!(grammar, Production(C, C, A, 0.33))
push!(grammar, Production(C, C, B, 0.33))
push!(grammar, Production(C, C, C, 0.33))
push!(grammar, Production(A, up, (), 0.01))
push!(grammar, Production(A, down, (), 0.01))
push!(grammar, Production(B, left, (), 0.01))
push!(grammar, Production(B, right, (), 0.01))
push!(grammar, Production(C, front, (), 0.01))
push!(grammar, Production(C, back, (), 0.01))
push!(grammar, Production(S, stop, (), 0.01))
println("Grammar")
map(x->println(x), grammar)

A = {(x.lhs::Nonterminal, x.lrhs::Nonterminal, x.rrhs::Nonterminal) => x.prob for x = filter( y-> isa(y.lrhs, Nonterminal), grammar) }
B = {(x.lhs::Nonterminal, x.lrhs::Terminal) => x.prob for x = filter( y-> isa(y.lrhs, Terminal), grammar) }
#println("A")
#show(A)
#println("B")
#show(B)

TEST = [1 0 0;0 1 0;0 0 1;1 0 0;0 0 1]
#TEST = randn(20,3)
#show(TEST)

E = inside(TEST, A, B)
Gamma, Tau = CYK(TEST, A, B)
show(Gamma)
show(Tau)
println()
